The Configuration client will read Kubernetes' ``ConfigMap``s and ``Secret``s instances and make them available as ``PropertySource``s
instances in your application.

Then, in any bean you can read the configuration values from the `ConfigMap` or `Secret` using `@Value` or
https://docs.micronaut.io/latest/guide/index.html#config[any other way to read configuration values].

Configuration parsing happens in the bootstrap phase. Therefore, to enable distributed configuration clients, define the
following in a `bootstrap` configuration file:

[configuration]
----
micronaut:
  config-client:
    enabled: true
----

## ConfigMaps

Supported formats for ``ConfigMap``s are:

* Java `.properties`.
* YAML.
* JSON.
* Literal values.

The configuration client by default will read all the ``ConfigMap``s for the configured namespace. You can further filter
which config map names are processed by defining `kubernetes.client.config-maps.includes` or
`kubernetes.client.config-maps.excludes`:

[configuration]
----
kubernetes:
  client:
    config-maps:
      includes:
        - my-config-map
        - other-config-map
----

Or:

[configuration]
----
kubernetes:
  client:
    config-maps:
      excludes: not-this-config-map
----

In addition to that, Kubernetes labels can be used to better match the config maps that should be available as property
sources. This can be done by defining the label and value directly:

[configuration]
----
kubernetes:
  client:
    config-maps:
      labels:
        - app: my-app
        - env: prod
----

Or by including every config map that has the same Kubernetes label as the pod the Micronaut application is running in.
This is handy if you use a package manager like https://helm.sh[Helm].
A good example would be `app.kubernetes.io/instance` which is a unique label identifying the instance of an application:

[configuration]
----
kubernetes:
  client:
    config-maps:
      pod-labels:
        - "app.kubernetes.io/instance"
----

Additionally, you can also enable `exception-on-pod-labels-missing` property in case you want an exception to be thrown if at least
one of the labels, specified in `pod-labels` section is not found among the application's pod labels. This can be useful if you want
to prevent loading all config maps available in namespace in case of mistyping or misconfiguration:

[configuration]
----
kubernetes:
  client:
    config-maps:
      exception-on-pod-labels-missing: true
      pod-labels:
        - "app.kubernetes.io/instance"
----

Note that on the resulting config maps, you can still further filter them with includes/excludes properties.

### Reading ``ConfigMap``s from mounted volumes

In the case of ``ConfigMaps``s, reading them from the Kubernetes API requires additional permissions, as stated above.
Therefore, you may want to read them from mounted volumes in the pod.

Given the following ConfigMap:

[source, yaml]
----
apiVersion: v1
kind: ConfigMap
metadata:
  name: mounted-config
data:
  mounted.yml: |-
    foo: bar
----

It can be mounted as a volume in a pod or deployment definition:

[source, yaml]
----
apiVersion: v1
kind: Pod
metadata:
  name: mypod
spec:
  containers:
  - name: mypod
    image: micronautapp
    volumeMounts:
    - name: configuration
      mountPath: /etc/configuration
      readOnly: true
  volumes:
  - name: configuration
    configMap:
      name: mounted-config
----

This will make Kubernetes to create file per data entry:

* `/etc/configuration/mounted.yml`

While you could potentially use the `java.io` or `java.nio` APIs to read the contents yourself, this configuration module
can convert them into a ``PropertySource`` so that you can consume the values much more easily. In order to do so, define
the following configuration:

[configuration]
----
kubernetes:
  client:
    config-maps:
      paths:
        - /etc/configuration
----

Each file in the directory will become a property source file. The file format will be automatically deduced based on the file suffix. Supported formats for mounted ``ConfigMap`` files are:

* Java `.properties`
* YAML
* JSON

[NOTE]
====
When `kubernetes.client.config-maps.paths` is defined, the Kubernetes API will not be used to read any other config maps.
If you still want to read the remaining config maps from the API, set the following configuration:

[configuration]
----
kubernetes:
  client:
    config-maps:
      use-api: true
      excludes: mounted-config  # Because it will be read as a mounted volume
      paths:
        - /etc/configuration
----

In this scenario, if there are property keys defined in both type of config maps, the ones coming from mounted volumes will
take precedence over the ones coming from the API.
====

### Watching for changes in ConfigMaps

By default, this configuration module will watch for ``ConfigMap``s added/modified/deleted, and provided that the changes
match with the above filters, they will be propagated to the `Environment` and refresh it.

This means that those changes will be immediately available in your application without a restart.

If you want to disable watching for ConfigMap changes, set `kubernetes.client.config-maps.watch` to `false`.
This should be done in the `bootstrap` configuration file because the configuration client is initialized during the bootstrap phase, which happens before evaluating the `application` configuration file.

[NOTE]
====
When `kubernetes.client.config-maps.use-api` is set to `false`, watching for the changes won't be started.
====

### Examples

You can create a Kubernetes `ConfigMap` off an existing file with the following command:

`kubectl create configmap my-config --from-file=my-config.properties`

Or:

`kubectl create configmap my-config --from-file=my-config.yml`

Or:

`kubectl create configmap my-config --from-file=my-config.json`

You can also create a `ConfigMap` from literal values:

`kubectl create configmap my-config --from-literal=special.how=very --from-literal=special.type=charm`

## Secrets

Secrets read from the Kubernetes API will be base64-decoded and made available as `PropertySource` s, so that they can be
also read with `@Value`, `@ConfigurationProperties`, etc.

NOTE: Only `Opaque` secrets will be considered.

By default, secrets access is disabled. To enable it, change it in the `bootstrap` configuration file:

[configuration]
----
kubernetes:
  client:
    secrets:
      enabled: true
----

The configuration client, by default, will read all the ``Secret``s for the configured namespace. You can further filter
which config map names are processed by defining `kubernetes.client.secrets.includes` or `kubernetes.client.secrets.excludes`:

[configuration]
----
kubernetes:
  client:
    secrets:
      enabled: true
      includes: this-secret
----

Or:

[configuration]
----
kubernetes:
  client:
    secrets:
      enabled: true
      excludes: not-this-secret
----

Similarly to ``ConfigMap``s, labels can also be used to match the desired secrets:

[configuration]
----
kubernetes:
  client:
    secrets:
      enabled: true
      labels:
        - app: my-app
        - env: prod
----

This also works for pod labels:

[configuration]
----
kubernetes:
  client:
    secrets:
      enabled: true
      pod-labels:
        - "app.kubernetes.io/instance"
----

As well as `exception-on-pod-labels-missing` property:

[configuration]
----
kubernetes:
  client:
    secrets:
      enabled: true
      exception-on-pod-labels-missing: true
      pod-labels:
        - "app.kubernetes.io/instance"
----

### Reading ``Secret``s from mounted volumes

In the case of ``Secret``s, reading them from the Kubernetes API requires additional permissions, as stated above.
Therefore, you may want to read them from mounted volumes in the pod.

Given the following secret:

[configuration]
----
apiVersion: v1
kind: Secret
metadata:
  name: mysecret
type: Opaque
data:
  username: YWRtaW4=
  password: MWYyZDFlMmU2N2Rm
----

It can be mounted as a volume in a pod or deployment definition:

[configuration]
----
apiVersion: v1
kind: Pod
metadata:
  name: mypod
spec:
  containers:
  - name: mypod
    image: redis
    volumeMounts:
    - name: foo
      mountPath: "/etc/foo"
      readOnly: true
  volumes:
  - name: foo
    secret:
      secretName: mysecret
----

This will make Kubernetes to create 2 files:

* `/etc/foo/username`.
* `/etc/foo/password`.

Their content will be the decoded strings from the original base-64 encoded values.

While you could potentially use the `java.io` or `java.nio` APIs to read the contents yourself, this configuration module
can convert them into a ``PropertySource`` so that you can consume the values much more easily. In order to do so, define
the following configuration:

[configuration]
----
kubernetes:
  client:
    secrets:
      enabled: true
      paths:
        - /etc/foo
----

Each file in the directory will become the property key, and the file contents, the property value.

[NOTE]
====
When `kubernetes.client.secrets.paths` is defined, the Kubernetes API will not be used to read any other secret.
If you still want to read the remaining secrets from the API, set the following configuration:

[configuration]
----
kubernetes:
  client:
    secrets:
      enabled: true
      use-api: true
      excludes: mysecret  # Because it will be read as a mounted volume
      paths:
        - /etc/foo
----

In this scenario, if there are property keys defined in both type of secrets, the ones coming from mounted volumes will
take precedence over the ones coming from the API.
====
