The Service Discovery module allows Micronaut HTTP clients to discover Kubernetes services.

By default in any client you can use as Service ID the Kubernetes `Endpoints` name generated by a Kubernetes `Service` for the configured namespace.

Consider the following Kubernetes service definition:

[source,yaml]
.`my-service.yml`
----
kind: Service
apiVersion: v1
metadata:
  name: my-service
spec:
  selector:
    app: MyApp
  ports:
  - protocol: TCP
    port: 80
    targetPort: 9376
----

This specification will create a new `Service` object named `my-service`, as well as an `Endpoints` object also named `my-service`.

In your HTTP client, you can use `my-service` as Service ID: `@Client("my-service")`.

Note that service discovery is enabled by default in Micronaut. To disable it, set `kubernetes.client.discovery.enabled`
to `false`.

## Service specific client configuration
https://kubernetes.io/docs/concepts/services-networking/service/[Kubernetes Service] is a complex resource that can handle various use cases by providing specific configuration.
For this Micronaut Kubernetes supports a manual service discovery configuration per Service http client that allows you to configure custom:

[%header, cols=2*]
|===
| Key
| Description

| `name`
| name of the resource in Kubernetes in case it is different than the Service ID

| `namespace`
| namespace of the resource in case it's different than the configured namespace

| `port`
| port name in case the target resource is a https://kubernetes.io/docs/concepts/services-networking/service/#multi-port-services[Multi-Port Service]

| `mode`
| service specific <<Service discovery modes,discovery mode>> in case it's different than the globally configured discovery mode
|===

### Examples of service configurations
#### Multi-port service
For the following https://kubernetes.io/docs/concepts/services-networking/service/#multi-port-services[Multi-Port Service]:
[source, yaml]
.`my-service.yml`
----
apiVersion: v1
kind: Service
metadata:
  name: my-service
spec:
  selector:
    app: MyApp
  ports:
    - name: http
      protocol: TCP
      port: 80
      targetPort: 9376
    - name: https
      protocol: TCP
      port: 443
      targetPort: 9377
----

the manual service configuration for http port will be:
[source, yaml]
.`bootstrap.yml`
----
kubernetes:
  client:
    discovery:
      services:
        my-service:
          port: http
----

#### Headless service with selector
For the following https://kubernetes.io/docs/concepts/services-networking/service/#headless-services[Headless service] with selector:
[source, yaml]
.`my-service.yml`
----
apiVersion: v1
kind: Service
metadata:
  name: my-service
spec:
  clusterIP: None
  selector:
    app: MyApp
  ports:
    - name: http
      protocol: TCP
      port: 80
      targetPort: 9376
----
the manual service configuration will be:
[source, yaml]
.`bootstrap.yml`
----
kubernetes:
  client:
    discovery:
      services:
        my-service:
          mode: endpoint
----

#### ExternalName service type
For the following https://kubernetes.io/docs/concepts/services-networking/service/#externalname[ExternalName service]:
[source, yaml]
.`my-service.yml`
----
apiVersion: v1
kind: Service
metadata:
  name: my-service
  namespace: prod
spec:
  type: ExternalName
  externalName: launch.micronaut.io
----
the manual service configuration will be:
[source, yaml]
.`bootstrap.yml`
----
kubernetes:
  client:
    discovery:
      services:
        my-service:
          mode: service
----

## Service discovery modes

Service discovery mode is a mechanism that allows to support different strategies for the actual service discovery in Kubernetes by implementing api:kubernetes.discovery.KubernetesServiceInstanceProvider[] interface.

Currently Micronaut Kubernetes implements two discovery modes:

* `endpoint` mode uses the Kubernetes `Endpoins` API for the service discovery. Note that the service load balancing is handled by Microunat application.
* `service` mode uses the Kubernetes `Service` API for the service discovery. The `service` mode extracts the service `ClusterIP` address from the Service status.

Both discovery modes are using the `metadata.name` for the Service ID identificator.

The discovery mode can be configured globally for all Service IDs or per service.
Note that `endpoint` is the default global discovery mode. That can be overridden via configuration in `bootstrap.yml`:
[source, yaml]
.`bootstrap.yml`
----
kubernetes:
  client:
    discovery:
      mode: service
----

## Kubernetes API authentication

Micronaut authenticates to the Kubernetes API using the token mounted at `/var/run/secrets/kubernetes.io/serviceaccount/token`.
Note that by default, the service account used may only have permissions over the `kube-system` namespace. The service discovery
functionality requires some additiona read permissions. Refer to the 
https://kubernetes.io/docs/reference/access-authn-authz/rbac/[Kubernetes documentation] for more information
about Role-based access control (RBAC).

One of the options is to create the following `Role` and `RoleBinding` (make sure to apply them to the service account used, 
if not `default`):

[source,yaml]
.`auth.yml`
----
include::{sourcedir}/k8s-auth.yml[]
----

[NOTE]
In Google Cloud's Kubernetes Engine, in order to create the above, you must grant your user the ability to create roles
in Kubernetes by running the following command:

    kubectl create clusterrolebinding cluster-admin-binding --clusterrole cluster-admin --user yourGoogleAccount@gmail.com

## Connecting to services using HTTPS

There are three ways for this library to determine whether a service should be connected to using SSL (the following
examples assume there is a `Deployment` named `secure-deployment`).

### Using `https` as port name

[source,yaml]
.`my-service.yml`
----
include::{sourcedir}/kubernetes.yml[tag=port-name]
----

### Using a port ending in 443

Port numbers like 443, 8443, etc. will match.

[source,yaml]
.`my-service.yml`
----
include::{sourcedir}/kubernetes.yml[tag=port-number]
----

### Using labels

Set a label named `secure` with value `true` to have the client use HTTPS.

[source,yaml]
.`my-service.yml`
----
include::{sourcedir}/kubernetes.yml[tag=labels]
----

## Service filtering

You can filter the services discovered by using `kubernetes.client.discovery.includes` or
`kubernetes.client.discovery.excludes`:

[source,yaml]
----
kubernetes:
  client:
    discovery:
      includes:
        - my-service
        - other-service
----

Or:

[source,yaml]
----
kubernetes:
  client:
    discovery:
      excludes: not-this-service
----

In addition to that, Kubernetes labels can be used to better match the services that should be available for service
discovery:

[source,yaml]
----
kubernetes:
  client:
    discovery:
      labels:
        - app: my-app
        - env: prod
----

Note that the filtering is not applied on manually configured service configurations.
